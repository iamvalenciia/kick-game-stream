package game_test

import (
	"testing"

	"fight-club/internal/game"
)

// TestNewPlayer tests player creation with defaults
func TestNewPlayer(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})

	if player == nil {
		t.Fatal("NewPlayer returned nil")
	}
	if player.Name != "TestPlayer" {
		t.Errorf("Expected name 'TestPlayer', got '%s'", player.Name)
	}
	if player.HP != 100 {
		t.Errorf("Expected HP 100, got %d", player.HP)
	}
	if player.MaxHP != 100 {
		t.Errorf("Expected MaxHP 100, got %d", player.MaxHP)
	}
	if player.Weapon != "fists" {
		t.Errorf("Expected weapon 'fists', got '%s'", player.Weapon)
	}
	if player.Money != 0 {
		t.Errorf("Expected money 0, got %d", player.Money)
	}
	if !player.SpawnProtection {
		t.Error("New player should have spawn protection")
	}
}

// TestNewPlayerWithOptions tests player creation with custom options
func TestNewPlayerWithOptions(t *testing.T) {
	opts := game.PlayerOptions{
		ProfilePic: "http://example.com/pic.png",
		Color:      "#ff0000",
	}
	player := game.NewPlayer("CustomPlayer", opts)

	if player.Color != "#ff0000" {
		t.Errorf("Expected color '#ff0000', got '%s'", player.Color)
	}
	if player.ProfilePic != "http://example.com/pic.png" {
		t.Errorf("Expected profilePic to be set")
	}
}

// TestPlayerTakeDamage tests damage application
func TestPlayerTakeDamage(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.SpawnProtection = false

	attacker := game.NewPlayer("Attacker", game.PlayerOptions{})

	initialHP := player.HP
	player.TakeDamage(30, attacker)

	if player.HP != initialHP-30 {
		t.Errorf("Expected HP %d, got %d", initialHP-30, player.HP)
	}
}

// TestPlayerTakeDamageWithProtection tests spawn protection
func TestPlayerTakeDamageWithProtection(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.SpawnProtection = true

	initialHP := player.HP
	player.TakeDamage(50, nil)

	if player.HP != initialHP {
		t.Error("Player with spawn protection should not take damage")
	}
}

// TestPlayerDeath tests player death
func TestPlayerDeath(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.SpawnProtection = false
	player.HP = 10

	attacker := game.NewPlayer("Attacker", game.PlayerOptions{})
	attacker.SpawnProtection = false

	player.TakeDamage(20, attacker)

	if !player.IsDead {
		t.Error("Player should be dead after taking fatal damage")
	}
	if !player.IsRagdoll {
		t.Error("Dead player should be in ragdoll state")
	}
	if player.Deaths != 1 {
		t.Errorf("Expected 1 death, got %d", player.Deaths)
	}
}

// TestPlayerHeal tests healing
func TestPlayerHeal(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.HP = 50

	player.Heal(30)

	if player.HP != 80 {
		t.Errorf("Expected HP 80, got %d", player.HP)
	}
}

// TestPlayerHealCap tests healing doesn't exceed max
func TestPlayerHealCap(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.HP = 90

	player.Heal(50)

	if player.HP > player.MaxHP {
		t.Errorf("HP should not exceed MaxHP, got %d", player.HP)
	}
}

// TestPlayerRespawn tests respawning
func TestPlayerRespawn(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.SpawnProtection = false
	player.HP = 1
	player.TakeDamage(10, nil)

	if !player.IsDead {
		t.Fatal("Player should be dead")
	}

	player.Respawn()

	if player.IsDead {
		t.Error("Player should not be dead after respawn")
	}
	if player.IsRagdoll {
		t.Error("Player should not be ragdoll after respawn")
	}
	if player.HP != player.MaxHP {
		t.Error("Player should have full HP after respawn")
	}
	if !player.SpawnProtection {
		t.Error("Player should have spawn protection after respawn")
	}
}

// TestPlayerDistanceTo tests distance calculation
func TestPlayerDistanceTo(t *testing.T) {
	player1 := game.NewPlayer("P1", game.PlayerOptions{})
	player1.X = 0
	player1.Y = 0

	player2 := game.NewPlayer("P2", game.PlayerOptions{})
	player2.X = 3
	player2.Y = 4

	// Distance should be 5 (3-4-5 triangle)
	// We need to expose distanceTo or test via collision
}

// TestPlayerResolveCollisions tests collision resolution
func TestPlayerResolveCollisions(t *testing.T) {
	players := []*game.Player{
		game.NewPlayer("P1", game.PlayerOptions{}),
		game.NewPlayer("P2", game.PlayerOptions{}),
	}

	// Place players very close
	players[0].X = 100
	players[0].Y = 100
	players[1].X = 110 // Within collision radius (30+30=60)
	players[1].Y = 100

	initialX1 := players[0].X
	initialX2 := players[1].X

	players[0].ResolveCollisions(players)

	// Players should be pushed apart
	if players[0].X == initialX1 && players[1].X == initialX2 {
		// No collision detected if they didn't move - this is expected
		// since distance (10) is less than minDist (56)
	}
}

// TestPlayerToJSON tests JSON serialization
func TestPlayerToJSON(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.Kills = 5
	player.Deaths = 2
	player.Money = 150

	json := player.ToJSON()

	if json["name"] != "TestPlayer" {
		t.Error("JSON should contain correct name")
	}
	if json["kills"] != 5 {
		t.Error("JSON should contain correct kills")
	}
	if json["deaths"] != 2 {
		t.Error("JSON should contain correct deaths")
	}
	if json["money"] != 150 {
		t.Error("JSON should contain correct money")
	}
}

// TestPlayerUpdate tests player update with no target
func TestPlayerUpdate(t *testing.T) {
	engine := game.NewEngine(30)
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.SpawnProtection = false

	players := []*game.Player{player}

	// Update should not panic with empty player list
	player.Update(players, 0.033, engine)
}

// TestPlayerUpdateWithTarget tests player update with target
func TestPlayerUpdateWithTarget(t *testing.T) {
	engine := game.NewEngine(30)

	player1 := game.NewPlayer("P1", game.PlayerOptions{})
	player1.SpawnProtection = false
	player1.X = 100
	player1.Y = 100

	player2 := game.NewPlayer("P2", game.PlayerOptions{})
	player2.SpawnProtection = false
	player2.X = 200
	player2.Y = 100

	players := []*game.Player{player1, player2}

	// Run several updates
	for i := 0; i < 30; i++ {
		player1.Update(players, 0.033, engine)
	}

	// Player should have moved towards target
	if player1.X <= 100 {
		t.Error("Player should have moved towards target")
	}
}

// TestPlayerUpdateRagdoll tests ragdoll physics
func TestPlayerUpdateRagdoll(t *testing.T) {
	player := game.NewPlayer("TestPlayer", game.PlayerOptions{})
	player.SpawnProtection = false
	player.HP = 1
	player.TakeDamage(10, nil)

	if !player.IsRagdoll {
		t.Fatal("Player should be ragdoll")
	}

	initialX := player.X
	player.VX = 5

	player.UpdateRagdoll(0.033)

	if player.X <= initialX {
		t.Error("Ragdoll should move based on velocity")
	}
}
